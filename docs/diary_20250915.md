# Development diary — 2025-09-15

Topic: Define UART–AXI4-Lite protocol (byte settings, frame order, read flow)

Decisions

- 8N1 UART at 115200 default, scalable to 3 Mbps
- Single-byte SOF markers: 0xA5 (request), 0x5A (response)
- Command bitfield: RW, INC, SIZE (8/16/32), LEN (1..16)
- Little-endian ADDR/DATA
- CRC-8 (poly 0x07) covering CMD..payload/STATUS
- Read response includes STATUS, CMD echo, ADDR echo, then DATA
- AXI4-Lite mapping with strict alignment; derive WSTRB from SIZE+ADDR

Rationale

- Keep framing minimal to reduce overhead but include CRC for robustness
- Echo `CMD` and `ADDR` in read responses to simplify host correlation and debugging
- Reject misalignment to avoid complicated split transfers on AXI4-Lite

Verification plan hooks

- Map to existing UVM env: use UART agent to drive frames, AXI monitor/scoreboard to check DUT
- Coverage: cross RW×INC×SIZE×LEN, alignment, WSTRB lanes, status codes
- Error injection: CRC flip, AXI SLVERR, timeout, misalignment

Open questions

- Do we want 2-byte SOF or byte-stuffing for harsh EMI environments?
- Maximum supported `LEN` at target baud to meet latency goals
- Do we need host-configurable baud switch command during runtime?

Next steps

- Prototype RTL: UART RX/TX + frame parser + AXI-Lite master
- Create UVM sequences to generate the example frames and negative tests
- Add a small host-side Python tool to craft frames and validate CRC
