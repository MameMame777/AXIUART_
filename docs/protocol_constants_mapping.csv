# Protocol Constants Mapping - AXIUART_ RTL Implementation

**ç”Ÿæˆæ—¥**: 2025å¹´10æœˆ6æ—¥  
**å¯¾è±¡**: RTLå®Ÿè£…ã§ã®å…¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«å®šæ•°ã®è©³ç´°ãƒãƒƒãƒ”ãƒ³ã‚°  
**åŸºæº–**: rtl_specification_analysis_20251006.md Phase 1èª¿æŸ»çµæœ

---

## ğŸ“Š Protocol Field Mapping Table

### SOF (Start of Frame) Constants

| Direction | RTL Constant | Value | Applied Mask | Final TX Value | Expected Value | Status |
|-----------|-------------|-------|--------------|---------------|----------------|---------|
| Host â†’ Device | SOF_HOST_TO_DEVICE | 0xA5 | None | 0xA5 | 0xA5 | âœ… Match |
| Device â†’ Host | SOF_DEVICE_TO_HOST | 0x5A | 0x31 | 0x6B | 0x2D | âŒ Mismatch |

**SOFä¸æ•´åˆè©³ç´°**:
- RTLè¨ˆç®—: 0x5A XOR 0x31 = 0x6B
- æœŸå¾…å€¤: 0x2D  
- å·®åˆ†: 0x46 (70 decimal)

### STATUS Constants

| Source | RTL Constant | Value | Applied Mask | Final TX Value | Expected Value | Status |
|---------|-------------|-------|--------------|---------------|----------------|---------|
| AXI Master | STATUS_OK | 0x00 | 0x60 | 0x60 | 0x6C | âŒ Mismatch |

**STATUSä¸æ•´åˆè©³ç´°**:
- RTLè¨ˆç®—: 0x00 XOR 0x60 = 0x60
- æœŸå¾…å€¤: 0x6C
- å·®åˆ†: 0x0C (12 decimal)

### CMD_ECHO Constants

| Field | Applied Mask | Original Value | Corrected Value | Purpose |
|--------|--------------|---------------|-----------------|---------|
| CMD_ECHO | 0x19 | cmd_value | cmd_value XOR 0x19 | Command echo correction |

**CMD_ECHOå‡¦ç†**:
- å…¥åŠ›: `captured_cmd` (Bridgeã§ã‚­ãƒ£ãƒ—ãƒãƒ£)
- ä¿®æ­£: cmd_value XOR 0x19
- å‡ºåŠ›: ä¿®æ­£ã•ã‚ŒãŸå€¤ã‚’UARTé€ä¿¡

---

## ğŸ”§ RTL Correction Mask System

### Hardware Correction Masks (Frame_Builder.sv)

```systemverilog
// å®šç¾©ç®‡æ‰€: line 42-44
localparam [7:0] SOF_CORRECTION_MASK = 8'h31;        // 0x5Aâ†’0x6B flip
localparam [7:0] CMD_CORRECTION_MASK = 8'h19;        // CMD correction  
localparam [7:0] STATUS_CORRECTION_MASK = 8'h60;     // 0x00â†’0x60 flip
```

### Correction Application Points

| Field | File | Line | Application |
|-------|------|------|-------------|
| SOF | Frame_Builder.sv | 199 | `SOF_DEVICE_TO_HOST ^ SOF_CORRECTION_MASK` |
| STATUS | Frame_Builder.sv | 218 | `status_reg ^ STATUS_CORRECTION_MASK` |
| CMD | Frame_Builder.sv | 238 | `cmd_reg ^ CMD_CORRECTION_MASK` |

---

## ğŸ“ Data Flow Traceability

### SOF Data Flow
```
Constant: 0x5A â†’ Correction: XOR 0x31 â†’ TX FIFO: 0x6B â†’ UART TX â†’ Serial Output
```

### STATUS Data Flow
```
AXI Master: 0x00 â†’ Bridge: 0x00 â†’ Frame Builder: 0x00 â†’ Correction: XOR 0x60 â†’ TX FIFO: 0x60 â†’ UART TX
```

### CMD_ECHO Data Flow
```
Frame Parser: cmd â†’ Bridge Capture: captured_cmd â†’ Frame Builder: cmd_reg â†’ Correction: XOR 0x19 â†’ TX FIFO
```

---

## ğŸ¯ Root Cause Analysis

### Identified Issues

1. **SOF Mask Inconsistency**
   - Current mask: 0x31 produces 0x6B
   - Required mask for 0x2D: 0x77 (0x5A XOR 0x2D = 0x77)

2. **STATUS Mask Inconsistency**  
   - Current mask: 0x60 produces 0x60
   - Required mask for 0x6C: 0x6C (0x00 XOR 0x6C = 0x6C)

3. **Correction System Functioning Properly**
   - Hardware correction mechanism is working as designed
   - Issue is in mask values, not application logic

---

## ğŸ“ Recommendations for Phase 2

### Protocol Specification Verification
1. Confirm expected SOF value (0x2D vs 0x6B)
2. Confirm expected STATUS value (0x6C vs 0x60) 
3. Verify test specification accuracy
4. Cross-reference with protocol documentation

### Immediate Actions
1. Document current RTL behavior as baseline
2. Identify source of expected values (0x2D, 0x6C)
3. Determine if RTL or test expectations need correction
4. Plan systematic resolution approach

---

## ğŸ“Š Protocol Integrity Assessment

**Current Status**: âŒ **Protocol Mismatch Confirmed**

**Impact**:
- System integration tests failing
- Development process blocked  
- Protocol layer inconsistency

**Next Phase Priority**: Phase 2 - Protocol specification analysis and gap resolution