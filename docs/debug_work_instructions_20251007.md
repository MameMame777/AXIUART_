# Debug Work Instructions - October 7, 2025

## 🎯 **作業指示書概要**

**目的**: UVMシミュレーションで発見されたCRCエラーとAXIアライメントエラーを段階的に解決し、レジスタアクセス機能を完全に動作させる

**作業分割方針**: 各作業を小さな検証可能なステップに分割し、チェックリスト形式で進捗管理を行う

**成功条件**: UVMシミュレーションでレジスタ書き込み・読み出しが正常動作すること

---

## 📋 **Phase 1: CRC計算エラー解決**

### Step 1-1: CRCエラー状況の詳細分析
- [ ] **1-1-1**: UVMログファイル `dsim.log` でCRCエラーメッセージを特定
  ```bash
  cd sim/uvm
  grep -n "CRC" dsim.log | head -20
  ```
- [ ] **1-1-2**: エラー発生タイミングを特定（送信フレーム vs 受信フレーム）
- [ ] **1-1-3**: 具体的なCRC値を記録（期待値・実際値・対象データ）
- [ ] **1-1-4**: エラー発生頻度を確認（全フレーム vs 特定条件）

**検証方法**: ログファイルからCRCエラーの詳細情報を抽出し、問題パターンを特定

### Step 1-2: Frame_Parser.sv CRC実装の確認
- [ ] **1-2-1**: `rtl/Frame_Parser.sv` のCRC計算部分を読み込み
  ```bash
  cd rtl
  grep -n -A 10 -B 5 "crc" Frame_Parser.sv
  ```
- [ ] **1-2-2**: CRC8多項式0x07の実装を確認
- [ ] **1-2-3**: CRC初期値の設定を確認
- [ ] **1-2-4**: CRC計算対象データの範囲を確認
- [ ] **1-2-5**: バイト順序（MSB first vs LSB first）を確認

**検証方法**: ソースコード解析でCRC実装の詳細を把握

### Step 1-3: CRC計算の参照実装作成
- [ ] **1-3-1**: Python参照実装を作成
  ```python
  def crc8_calc(data, polynomial=0x07):
      # Reference implementation
  ```
- [ ] **1-3-2**: 既知のテストベクタでPython実装を検証
- [ ] **1-3-3**: UVMで使用している実際のデータでPython CRCを計算
- [ ] **1-3-4**: SystemVerilog実装との結果比較

**検証方法**: 参照実装で正しいCRC値を算出し、RTL実装と比較

### Step 1-4: SystemVerilog CRC実装の修正
- [ ] **1-4-1**: CRC計算アルゴリズムの問題箇所を特定
- [ ] **1-4-2**: バイト順序問題があれば修正
- [ ] **1-4-3**: 多項式実装の問題があれば修正
- [ ] **1-4-4**: 初期値・最終値処理の問題があれば修正
- [ ] **1-4-5**: 修正後のRTLでコンパイル確認

**検証方法**: RTL修正後、コンパイルエラーがないことを確認

### Step 1-5: CRC修正の動作確認
- [ ] **1-5-1**: 修正されたRTLでUVMシミュレーション実行
  ```bash
  cd sim/uvm
  .\run_uvm.ps1
  ```
- [ ] **1-5-2**: CRCエラーの解消を確認
- [ ] **1-5-3**: 新たなエラーが発生していないことを確認
- [ ] **1-5-4**: 波形ファイルでCRC計算タイミングを確認

**検証方法**: UVMテスト実行でCRCエラーが解消されること

---

## 📋 **Phase 2: AXIアライメントエラー解決**

### Step 2-1: アライメントエラーの詳細分析
- [ ] **2-1-1**: UVMログで `CHECK_ALIGNMENT -> ERROR` の発生箇所を特定
- [ ] **2-1-2**: エラー発生時のアドレス値を記録
- [ ] **2-1-3**: 対象レジスタアドレス（0x1000, 0x1004, 0x1008, 0x100C）での発生パターン確認
- [ ] **2-1-4**: アライメントチェックの期待動作を確認

**検証方法**: アライメントエラーの発生条件とアドレスパターンを特定

### Step 2-2: Address_Aligner.sv の実装確認
- [ ] **2-2-1**: `rtl/Address_Aligner.sv` のアライメントチェックロジックを確認
- [ ] **2-2-2**: `addr_ok` 信号生成ロジックを確認
- [ ] **2-2-3**: 32bit アライメント判定の実装を確認
- [ ] **2-2-4**: レジスタベースアドレス0x1000との整合性を確認
- [ ] **2-2-5**: AXI プロトコル仕様との適合性を確認

**検証方法**: ソースコード解析でアライメント判定ロジックを把握

### Step 2-3: アライメント判定の修正
- [ ] **2-3-1**: 32bit境界判定の問題箇所を特定
- [ ] **2-3-2**: レジスタアドレス（0x1000系）でのアライメント判定を修正
- [ ] **2-3-3**: `addr_ok` 信号の生成条件を修正
- [ ] **2-3-4**: AXI Master状態遷移への影響を確認
- [ ] **2-3-5**: 修正後のコンパイル確認

**検証方法**: RTL修正後、コンパイルエラーがないことを確認

### Step 2-4: AXI Master状態遷移の確認
- [ ] **2-4-1**: `rtl/Axi_Master.sv` の状態遷移を確認
- [ ] **2-4-2**: アライメントエラー時の状態処理を確認
- [ ] **2-4-3**: `addr_ok` 信号と状態遷移の関係を確認
- [ ] **2-4-4**: エラー状態からの復帰処理を確認
- [ ] **2-4-5**: AXI プロトコル準拠性を確認

**検証方法**: 状態遷移図と実装の整合性を確認

### Step 2-5: アライメント修正の動作確認
- [ ] **2-5-1**: 修正されたRTLでUVMシミュレーション実行
- [ ] **2-5-2**: アライメントエラーの解消を確認
- [ ] **2-5-3**: AXI トランザクションの正常実行を確認
- [ ] **2-5-4**: 波形ファイルでAXI 信号タイミングを確認

**検証方法**: UVMテスト実行でアライメントエラーが解消されること

---

## 📋 **Phase 3: レジスタアクセス動作検証**

### Step 3-1: AXI トランザクション到達確認
- [ ] **3-1-1**: UVMシミュレーションでAXI 書き込みトランザクション実行
- [ ] **3-1-2**: Register_Block.sv への信号到達を波形で確認
- [ ] **3-1-3**: アドレスデコードの正常動作を確認
- [ ] **3-1-4**: 書き込みイネーブル信号の生成を確認
- [ ] **3-1-5**: AXI応答信号（BRESP）の正常性を確認

**検証方法**: 波形解析でAXI信号がRegister_Blockまで正しく伝達されること

### Step 3-2: レジスタ書き込み動作確認
- [ ] **3-2-1**: CONFIGレジスタ（0x1000）への0x44444444書き込みテスト
- [ ] **3-2-2**: DEBUGレジスタ（0x1004）への0x12345678書き込みテスト
- [ ] **3-2-3**: STATUSレジスタ（0x1008）への書き込み確認
- [ ] **3-2-4**: CONTROLレジスタ（0x100C）への書き込み確認
- [ ] **3-2-5**: 各レジスタの内部状態を波形で確認

**検証方法**: 各レジスタに期待値が正しく書き込まれること

### Step 3-3: レジスタ読み出し動作確認
- [ ] **3-3-1**: 書き込み後のCONFIGレジスタ読み出し（期待値: 0x44444444）
- [ ] **3-3-2**: 書き込み後のDEBUGレジスタ読み出し（期待値: 0x12345678）
- [ ] **3-3-3**: 読み出しデータのAXI応答確認
- [ ] **3-3-4**: UART応答フレームでの読み出し値確認
- [ ] **3-3-5**: データ永続化の確認（複数回読み出し）

**検証方法**: 書き込んだ値が正しく読み出されること

### Step 3-4: データ永続化テスト
- [ ] **3-4-1**: 連続書き込み・読み出しテスト
- [ ] **3-4-2**: 異なるレジスタへの交互アクセステスト
- [ ] **3-4-3**: レジスタ値の保持確認
- [ ] **3-4-4**: UVMテスト完了後の最終レジスタ状態確認
- [ ] **3-4-5**: エラー条件での動作確認

**検証方法**: 全てのレジスタアクセスが仕様通りに動作すること

---

## 📋 **Phase 4: 統合テスト & FPGA準備**

### Step 4-1: 完全なUVMテスト実行
- [ ] **4-1-1**: 全ての修正を統合したRTLでUVMテスト実行
- [ ] **4-1-2**: エラーレス実行の確認（UVM_ERROR: 0）
- [ ] **4-1-3**: 全レジスタアクセスパターンのテスト
- [ ] **4-1-4**: プロトコル準拠性の最終確認
- [ ] **4-1-5**: 性能・タイミング要件の確認

**検証方法**: 包括的なUVMテストが全て成功すること

### Step 4-2: FPGA実装準備
- [ ] **4-2-1**: 修正されたRTLファイルの整合性確認
- [ ] **4-2-2**: Vivado合成用制約ファイルの確認
- [ ] **4-2-3**: ピン配置・クロック設定の確認
- [ ] **4-2-4**: FPGA実装プロジェクトファイルの更新
- [ ] **4-2-5**: 合成・実装・ビットストリーム生成の実行

**検証方法**: FPGA実装が成功し、プログラミングファイルが生成されること

### Step 4-3: ハードウェア検証準備
- [ ] **4-3-1**: Python テストスクリプトの更新
- [ ] **4-3-2**: 期待値テストケースの準備
- [ ] **4-3-3**: FPGA プログラミング手順の確認
- [ ] **4-3-4**: ハードウェア接続・通信確認
- [ ] **4-3-5**: テスト環境の最終確認

**検証方法**: ハードウェアテスト環境が正常に動作すること

---

## 🔧 **チェックリスト運用指示**

### 作業開始時
1. **現在のTodo状態確認**: `manage_todo_list read` で進捗確認
2. **作業開始宣言**: 着手するPhaseのTodoを `in-progress` に変更
3. **環境確認**: DSIM環境変数とGit状態を確認

### 各Step実行時
1. **チェックボックス確認**: 各項目を順番に実行
2. **検証実行**: 各Stepの検証方法を必ず実施
3. **結果記録**: 成功・失敗・発見事項をコメントで記録
4. **問題発生時**: 即座に作業を中断し、問題分析を実施

### Phase完了時
1. **完了確認**: 全てのチェックボックスが完了していることを確認
2. **動作検証**: Phase全体の動作検証を実施
3. **Git Commit**: 修正内容と検証結果をコミット
4. **Todo更新**: 該当TodoをCompletedに変更し、次のPhaseをin-progressに設定

### 品質保証
- **コンパイルエラー**: RTL修正後は必ずコンパイル確認
- **回帰テスト**: 新たな問題が発生していないことを確認
- **文書化**: 発見事項・修正内容・教訓を記録
- **チーム共有**: 重要な発見は開発日記に記録

---

## 📊 **進捗管理**

### Phase完了判定基準
- **Phase 1**: CRCエラーが完全に解消され、フレーム検証が成功
- **Phase 2**: アライメントエラーが解消され、AXIトランザクションが実行
- **Phase 3**: レジスタ書き込み・読み出しが正常動作
- **Phase 4**: FPGA実装準備完了、ハードウェアテスト可能

### 品質ゲート
- 各Phase完了時にUVMテスト実行
- エラーレス実行の確認
- 前Phase機能の回帰確認
- 文書化・Git管理の実施

### エスカレーション条件
- Step完了に2時間以上要する場合
- 予期しない新たな問題が発見された場合
- 修正により他の機能に影響が生じた場合

---

*この作業指示書に従って段階的にデバッグを実行し、確実にレジスタアクセス機能を実現すること*