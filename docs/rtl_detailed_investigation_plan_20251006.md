# 🔍 AXIUART_ RTLプロトコル違反詳細調査作業指示書

**作成日**: 2025年10月6日  
**対象プロジェクト**: AXIUART_ UART-AXI4 Lite Bridge System  
**調査目的**: UART送信経路でのビットパターン変換問題の根本原因特定

---

## 📊 現状分析と問題定義

### 確認されたプロトコル違反

| フィールド | 期待値 | 実際値 | ビットパターン変化 | XORパターン |
|------------|--------|--------|-------------------|-------------|
| **SOF** | `0x5A` | `0xAD` | `01011010` → `10101101` | `0xF7` (7ビット変化) |
| **CMD_ECHO** | `0x20` | `0x48` | `00100000` → `01001000` | `0x68` (3ビット変化) |
| **STATUS** | `0x00` | `0x80` | `00000000` → `10000000` | `0x80` (1ビット変化) |
| **STATUS** | `0x00` | `0x83` | `00000000` → `10000011` | `0x83` (3ビット変化) |

### 調査基本方針

1. **RTLコード静的解析**: 各モジュールのビット操作ロジック確認
2. **データパス追跡**: Frame_Builder → UART TX → 物理ピンまでの完全なデータフロー
3. **タイミング解析**: クロックドメイン境界とタイミング制約の検証
4. **ハードウェア設定確認**: FPGA I/O設定とピン配置の検証

---

## 🚀 Phase 1: RTLモジュール静的解析

### タスク 1.1: Frame_Builder.sv 詳細解析
**目標**: SOF送信ロジックとビット操作の完全理解  
**予想工数**: 半日

#### 1.1.1 SOF送信ロジック解析
- [ ] **1.1.1.1** SOF定数定義確認
  ```systemverilog
  // 対象: Frame_Builder.sv lines 37-42
  localparam [7:0] SOF_DEVICE_TO_HOST = 8'h5A;
  localparam [7:0] SOF_CORRECTION_MASK = 8'hF7;
  localparam [7:0] SOF_DEVICE_TO_HOST_CORRECTED = SOF_DEVICE_TO_HOST ^ SOF_CORRECTION_MASK;
  ```

- [ ] **1.1.1.2** SOF送信状態機械解析
  ```systemverilog
  // 対象: Frame_Builder.sv lines 190-210 (SOF状態)
  // 確認項目: tx_fifo_data への代入値
  // 現在: SOF_DEVICE_TO_HOST (0x5A) を使用
  ```

- [ ] **1.1.1.3** 修正マスクロジック残存確認
  - [ ] SOF_CORRECTION_MASK の使用箇所検索
  - [ ] 条件分岐での修正適用有無確認
  - [ ] デバッグモード/リリースモードでの動作差異確認

#### 1.1.2 CMD_ECHO送信ロジック解析
- [ ] **1.1.2.1** CMD状態の送信ロジック確認
  ```systemverilog
  // 対象: Frame_Builder.sv lines 230-250 (CMD状態)
  // 確認項目: cmd_reg の値がどこから来るか
  // tx_fifo_data = cmd_reg; の直前の cmd_reg 値
  ```

- [ ] **1.1.2.2** cmd_reg更新ロジック確認
  ```systemverilog
  // 対象: Frame_Builder.sv lines 130-140
  // cmd_reg <= cmd_echo; の実行タイミング
  // cmd_echo の値の追跡
  ```

#### 1.1.3 STATUS送信ロジック解析
- [ ] **1.1.3.1** STATUS状態の送信ロジック確認
  ```systemverilog
  // 対象: Frame_Builder.sv lines 211-229 (STATUS状態)
  // status_reg の値と tx_fifo_data への代入
  ```

- [ ] **1.1.3.2** status_reg更新ロジック確認
  ```systemverilog
  // 対象: Frame_Builder.sv lines 134
  // status_reg <= status_code; の実行と値の追跡
  ```

**成功基準**: Frame_Builder内でのビット変換の有無を完全に特定

### タスク 1.2: Uart_Axi4_Bridge.sv 信号パス解析
**目標**: Frame_Builderに渡される値の正確性確認  
**予想工数**: 半日

#### 1.2.1 captured_cmd ロジック検証
- [ ] **1.2.1.1** captured_cmd レジスタ更新ロジック確認
  ```systemverilog
  // 対象: Uart_Axi4_Bridge.sv lines 328-340
  // captured_cmd <= parser_cmd; の実行条件と値
  ```

- [ ] **1.2.1.2** builder_cmd_echo 代入ロジック確認
  ```systemverilog
  // 対象: Uart_Axi4_Bridge.sv lines 417, 471
  // builder_cmd_echo = captured_cmd; の実行タイミング
  ```

#### 1.2.2 status_code 生成ロジック解析
- [ ] **1.2.2.1** status_code 値の生成箇所特定
  ```systemverilog
  // AXI応答からのステータス生成ロジック
  // エラー条件とステータスコードの対応
  ```

- [ ] **1.2.2.2** builder_status_code 代入確認
  ```systemverilog
  // Frame_Builder への status_code 渡し方確認
  ```

**成功基準**: Bridge内での値変換の有無を完全に特定

### タスク 1.3: UART送信経路解析
**目標**: TX FIFO → UART TX → 物理ピンまでのデータ完全性確認  
**予想工数**: 1日

#### 1.3.1 TX FIFO解析
- [ ] **1.3.1.1** FIFO実装詳細確認
  ```systemverilog
  // FIFO深度、データ幅、タイミング
  // 書き込み/読み出しポインタロジック
  // データ格納時のビット操作有無
  ```

- [ ] **1.3.1.2** FIFO読み出しロジック確認
  ```systemverilog
  // rd_data の値と tx_data への接続
  // 読み出しタイミングとデータ安定性
  ```

#### 1.3.2 Uart_Tx.sv 詳細解析
- [ ] **1.3.2.1** データロードロジック確認
  ```systemverilog
  // tx_shift_reg <= tx_data; の実行
  // tx_data の値とレジスタへの格納
  ```

- [ ] **1.3.2.2** シリアル送信ロジック確認
  ```systemverilog
  // uart_tx_int = tx_shift_reg[0]; LSB first送信
  // tx_shift_reg_next = {1'b0, tx_shift_reg[7:1]}; 右シフト
  // ビット順序の正確性確認
  ```

- [ ] **1.3.2.3** 状態機械とタイミング確認
  ```systemverilog
  // START_BIT, DATA_BITS, STOP_BIT状態での動作
  // baud_tick との同期とタイミング
  ```

**成功基準**: UART TX内でのビット変換の有無を完全に特定

---

## 🔍 Phase 2: データフロー詳細追跡

### タスク 2.1: SOFデータフロー完全追跡
**目標**: 0x5A → 0xAD 変換点の特定  
**予想工数**: 半日

#### 2.1.1 各段階でのSOF値確認
- [ ] **2.1.1.1** Frame_Builder内でのSOF値
  ```systemverilog
  // debug_sof_raw = SOF_DEVICE_TO_HOST; (0x5A期待)
  // debug_sof_sent = ?; (実際の送信値)
  // tx_fifo_data = ?; (FIFO書き込み値)
  ```

- [ ] **2.1.1.2** TX FIFO内でのSOF値
  ```systemverilog
  // wr_data (書き込み時) vs rd_data (読み出し時)
  // メモリ格納と読み出しでの値変化確認
  ```

- [ ] **2.1.1.3** Uart_Tx内でのSOF値
  ```systemverilog
  // tx_data (入力) vs tx_shift_reg (格納後)
  // シフトレジスタ操作での値変化確認
  ```

- [ ] **2.1.1.4** 物理ピン出力でのSOF
  ```systemverilog
  // uart_tx_int vs 実際のuart_txピン出力
  // I/O バッファでの変換有無
  ```

#### 2.1.2 変換点特定
- [ ] **2.1.2.1** 各段階での実際値記録
  - [ ] Frame_Builder出力: `____`
  - [ ] TX FIFO格納値: `____`
  - [ ] TX FIFO読み出し値: `____`
  - [ ] Uart_Tx入力: `____`
  - [ ] Uart_Txシフトレジスタ: `____`
  - [ ] 物理ピン出力: `0xAD`

- [ ] **2.1.2.2** 変換発生段階の特定
  - [ ] 変換点: `_____________`
  - [ ] 変換メカニズム: `_____________`

**成功基準**: SOF変換の正確な発生箇所と原因を特定

### タスク 2.2: CMD_ECHOデータフロー追跡
**目標**: 0x20 → 0x48 変換点の特定  
**予想工数**: 半日

#### 2.2.1 各段階でのCMD_ECHO値確認
- [ ] **2.2.1.1** parser_cmd からcaptured_cmd
  ```systemverilog
  // parser_cmd = 0x20 (受信コマンド)
  // captured_cmd = ?; (キャプチャ後)
  ```

- [ ] **2.2.1.2** captured_cmd からbuilder_cmd_echo
  ```systemverilog
  // captured_cmd = ?;
  // builder_cmd_echo = ?;
  ```

- [ ] **2.2.1.3** cmd_echo からcmd_reg
  ```systemverilog
  // cmd_echo (Frame_Builder入力) = ?;
  // cmd_reg (Frame_Builder内部) = ?;
  ```

- [ ] **2.2.1.4** cmd_reg から送信
  ```systemverilog
  // tx_fifo_data = cmd_reg; での値
  // 最終的な送信値との比較
  ```

**成功基準**: CMD_ECHO変換の正確な発生箇所を特定

### タスク 2.3: STATUSデータフロー追跡
**目標**: 0x00 → 0x80/0x83 変換点の特定  
**予想工数**: 半日

#### 2.3.1 STATUS生成ロジック確認
- [ ] **2.3.1.1** AXI応答からのSTATUS生成
  ```systemverilog
  // AXI BRESP/RRESP値
  // STATUS変換ロジック
  // 期待STATUS値の計算
  ```

- [ ] **2.3.1.2** STATUS値の伝播確認
  ```systemverilog
  // builder_status_code = ?;
  // status_code (Frame_Builder入力) = ?;
  // status_reg (Frame_Builder内部) = ?;
  ```

**成功基準**: STATUS異常値の生成原因を特定

---

## 🔧 Phase 3: タイミング・クロック解析

### タスク 3.1: クロックドメイン解析
**目標**: クロック境界でのデータ破損確認  
**予想工数**: 半日

#### 3.1.1 クロックドメイン特定
- [ ] **3.1.1.1** システムクロック使用箇所確認
  ```systemverilog
  // Frame_Builder: clk domain
  // UART TX: clk domain  
  // TX FIFO: clk domain
  // 全て同一クロックドメインか確認
  ```

- [ ] **3.1.1.2** 非同期信号境界確認
  ```systemverilog
  // uart_cts_n (外部信号)
  // 他の非同期入力の有無
  ```

#### 3.1.2 セットアップ・ホールド時間解析
- [ ] **3.1.2.1** レジスタ間データ転送タイミング
  ```systemverilog
  // Frame_Builder → TX FIFO
  // TX FIFO → Uart_Tx
  // 各段階でのタイミング制約確認
  ```

- [ ] **3.1.2.2** 高速データパスの確認
  ```systemverilog
  // 125MHz @ 9600 baud での余裕度
  // クリティカルパスの特定
  ```

**成功基準**: タイミング起因のデータ破損の可能性を評価

### タスク 3.2: リセット信号解析
**目標**: リセット起因の異常動作確認  
**予想工数**: 1時間

#### 3.2.1 リセット分布確認
- [ ] **3.2.1.1** リセット信号の伝播
  ```systemverilog
  // rst信号の接続先全確認
  // リセット極性と同期/非同期
  ```

- [ ] **3.2.1.2** リセット解除タイミング
  ```systemverilog
  // Power-on-reset シーケンス
  // リセット解除後の初期値確認
  ```

**成功基準**: リセット起因の問題の有無を確認

---

## ⚙️ Phase 4: ハードウェア設定検証

### タスク 4.1: FPGA I/O設定確認
**目標**: ピン設定起因の問題除外  
**予想工数**: 1時間

#### 4.1.1 制約ファイル確認
- [ ] **4.1.1.1** .xdc ファイルでのUARTピン設定
  ```tcl
  # uart_tx ピンの設定確認
  # I/O標準: LVCMOS33
  # ドライブ強度: 12mA
  # スルーレート: SLOW/FAST
  ```

- [ ] **4.1.1.2** Zybo Z7-20 ハードウェア仕様確認
  ```
  # ピン配置の正確性
  # 電気的特性の適合性
  ```

#### 4.1.2 合成・実装レポート確認
- [ ] **4.1.2.1** 合成警告・エラー確認
  ```
  # ラッチ推論警告
  # タイミング違反警告
  # 未接続信号警告
  ```

- [ ] **4.1.2.2** 実装タイミングレポート確認
  ```
  # セットアップ・ホールド違反
  # クリティカルパス解析
  ```

**成功基準**: ハードウェア設定起因の問題を除外

---

## 📋 Phase 5: 総合診断・解決策立案

### タスク 5.1: 根本原因総合判定
**目標**: 調査結果の統合と原因特定  
**予想工数**: 半日

#### 5.1.1 調査結果統合
- [ ] **5.1.1.1** 各Phase調査結果まとめ
  - [ ] Phase 1 RTL解析結果: `_____________`
  - [ ] Phase 2 データフロー結果: `_____________`
  - [ ] Phase 3 タイミング解析結果: `_____________`
  - [ ] Phase 4 ハードウェア設定結果: `_____________`

- [ ] **5.1.1.2** 問題発生箇所の特定
  - [ ] SOF変換箇所: `_____________`
  - [ ] CMD_ECHO変換箇所: `_____________`
  - [ ] STATUS異常生成箇所: `_____________`

#### 5.1.2 根本原因特定
- [ ] **5.1.2.1** 最有力原因の決定
  - [ ] 原因カテゴリ: RTL論理 / タイミング / ハードウェア / その他
  - [ ] 具体的原因: `_____________`
  - [ ] 証拠・根拠: `_____________`

- [ ] **5.1.2.2** 他の可能性の排除
  - [ ] 排除された原因1: `_____________`
  - [ ] 排除理由: `_____________`
  - [ ] 排除された原因2: `_____________`
  - [ ] 排除理由: `_____________`

### タスク 5.2: 解決策立案・実装
**目標**: 根本的解決策の設計と実装  
**予想工数**: 1日

#### 5.2.1 解決策設計
- [ ] **5.2.1.1** 修正方針決定
  - [ ] 修正箇所: `_____________`
  - [ ] 修正内容: `_____________`
  - [ ] 修正方式: RTL変更 / 制約変更 / 設定変更

- [ ] **5.2.1.2** 修正案詳細設計
  ```systemverilog
  // 修正前コード:
  
  // 修正後コード:
  
  ```

#### 5.2.2 修正実装・検証
- [ ] **5.2.2.1** RTL修正実装
  - [ ] 対象ファイル修正完了
  - [ ] 構文チェック通過
  - [ ] 論理チェック通過

- [ ] **5.2.2.2** 修正効果検証
  - [ ] 合成・実装成功
  - [ ] タイミング制約満足
  - [ ] 機能テスト通過

- [ ] **5.2.2.3** プロトコル準拠確認
  - [ ] SOF値修正: 0x5A 正常送信確認
  - [ ] CMD_ECHO修正: 0x20 正常エコー確認  
  - [ ] STATUS修正: 0x00 正常ステータス確認

**成功基準**: プロトコル完全準拠の実現

---

## 📊 進捗管理・品質保証

### 日次作業チェックリスト
- [ ] **作業開始時確認**
  - [ ] 前日の調査結果記録確認
  - [ ] 対象ファイルのバックアップ作成
  - [ ] 開発環境の動作確認

- [ ] **作業中記録**
  - [ ] 重要な発見・仮説の即座記録
  - [ ] コード変更履歴の詳細記録
  - [ ] 暫定結論と次ステップの明確化

- [ ] **作業終了時確認**
  - [ ] 調査結果の構造化まとめ
  - [ ] 未完了タスクの明確化
  - [ ] 翌日作業計画の更新

### 品質保証基準
- [ ] **技術品質**
  - [ ] 仮説と検証の明確な分離
  - [ ] 客観的証拠に基づく結論
  - [ ] 再現可能な調査手順の記録

- [ ] **調査品質**
  - [ ] 系統的調査の実施
  - [ ] 見落とし防止のダブルチェック
  - [ ] 代替仮説の適切な検討

---

## 🎯 成功基準・完了条件

### Phase 1 完了基準
- ✅ **RTL静的解析100%完了**: Frame_Builder, Bridge, UART TX の全ロジック確認
- ✅ **ビット操作ロジック特定**: 意図しないビット変換ロジックの有無確認
- ✅ **修正マスク残存確認**: 過去の修正コードの影響度評価

### Phase 2 完了基準  
- ✅ **データフロー完全追跡**: 各段階での実際のデータ値記録
- ✅ **変換点特定**: SOF/CMD_ECHO/STATUS変換の正確な発生箇所特定
- ✅ **変換メカニズム解明**: なぜその変換が発生するかの理由特定

### Phase 3 完了基準
- ✅ **タイミング問題評価**: クロック/リセット起因問題の有無確認
- ✅ **制約適合性確認**: タイミング制約違反の有無確認

### Phase 4 完了基準
- ✅ **ハードウェア設定検証**: FPGA I/O設定の適切性確認
- ✅ **実装品質確認**: 合成・実装での警告・エラー解消

### Phase 5 完了基準
- ✅ **根本原因特定**: 明確で具体的な原因の特定
- ✅ **解決策実装**: 効果的な修正の実装と検証
- ✅ **プロトコル準拠達成**: 全フィールドの仕様準拠確認

### プロジェクト完了条件
- [ ] プロトコル違反の完全解消
- [ ] 修正内容の文書化完了
- [ ] 再発防止策の実装
- [ ] 知見の体系的整理と共有

---

## 📚 参考資料・技術リソース

### プロジェクト内部資料
- `docs/protocol_violation_diagnosis_20251006.md` - 現在までの調査結果
- `docs/uart_axi4_protocol.md` - プロトコル仕様書
- `docs/design_overview.md` - システム設計概要
- `temporary/bit_pattern_analysis.py` - ビットパターン解析結果

### RTL解析対象ファイル
- `rtl/Frame_Builder.sv` - SOF/CMD_ECHO/STATUS送信ロジック
- `rtl/Uart_Axi4_Bridge.sv` - 信号ブリッジロジック  
- `rtl/Uart_Tx.sv` - UART送信器実装
- `rtl/AXIUART_Top.sv` - トップレベル接続

### 開発・解析ツール
- **RTL解析**: VSCode + SystemVerilog拡張
- **波形解析**: ILA (Integrated Logic Analyzer)
- **プロトコル検証**: Python テストスクリプト
- **タイミング解析**: Vivado タイミングレポート

---

*SystemVerilogデザインエンジニアとして、論理的で系統的なアプローチにより*  
*プロトコル違反の根本原因を確実に特定し、恒久的な解決を実現します。* 🎯