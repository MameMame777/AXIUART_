# Development Diary - 2025-10-19

## Context

- Investigating UART AXI4 debug sequence hang where DUT never returns a response and DSIM job stalls.

## Actions

- Replaced the UART driver monitor-response wait with a non-blocking polling loop that enforces the configured frame timeout and publishes `STATUS_TIMEOUT` on failure.
- Propagated timeout results through `uart_frame_transaction` (`timeout_error` flag) and added a sequence-level guard to flag missing DUT responses immediately.
- Hardened the driver guard timeout so that the fatal escalation happens in the main thread even if the guard fork is disabled, guaranteeing termination under DSIM host pressure.

## Observations

- Previous implementation relied on blocking `uvm_tlm_analysis_fifo::get`, which could hold the driver open indefinitely when the monitor produced no response.
- Timeout metadata now surfaces cleanly to scoreboard/coverage through the transaction record.
- Guard firing flag prevents the timeout fatal from being lost when `disable fork` preempts the guard task.

## Next Steps

- Recompile and rerun `uart_axi4_basic_test` through MCP to confirm the UVM timeout fires after ~1 ms and the run terminates without hanging.
- Continue root-cause analysis on Frame_Builder / AXI response path to restore DUT replies.

---

## 2025-10-29 Updates

- Unified UART baud configuration across RTL and UVM by deriving the divisor from `UART_OVERSAMPLE`, eliminating stale 115200-specific literals.
- Refreshed register-programming sequences/tests (`system_integration_tests`, `axiuart_register_sweep_sequence`, `register_sequences`) to source baud/timeout fields from the shared constants.
- Ran `python mcp_server/mcp_client.py --tool run_uvm_simulation --test-name uart_axi4_basic_test --mode run --verbosity UVM_MEDIUM --waves --timeout 300`.
- DSIM run `uart_axi4_basic_test_20251029_204252.log` completed without UVM_FATAL/UVM_ERROR; only coverage warning (33.79% < 80%) remains, waveform captured at `archive/waveforms/uart_axi4_basic_test_20251029_204252.mxd`.
